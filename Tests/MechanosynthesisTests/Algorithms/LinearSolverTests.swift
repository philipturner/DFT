import XCTest
import Mechanosynthesis
import Numerics

// A set of tests for solving the 3D potential generated by a nucleus.
//
// Use Neumann boundary conditions for these tests. Also, use the point
// charge model. This would be the multipole expansion of the charge
// distribution created by spreading the nucleus across 8 cells.
final class LinearSolverTests: XCTestCase {
  // First, check the solution from the direct matrix method. Make the domain
  // small enough that the direct method executes in ~1 ms. It may be too small
  // to observe a significant speedup from multigrid relaxations, but that is
  // okay. We only need code for a multigrid that works at all.
  func testDirectMatrixMethod() throws {
    // Set up the Neumann boundaries, normalize to obey Gauss's Law.
    let h: Float = 0.25
    let gridSize: Int = 8
    
    // Create an array that represents the boundary values in each cell.
    //
    // Elements of the flux data structure:
    // - [0] = lower X face
    // - [1] = upper X face
    // - [2] = lower Y face
    // - [3] = upper Y face
    // - [4] = lower Z face
    // - [5] = upper Z face
    var fluxGrid = [SIMD8<Float>](
      repeating: .zero, count: gridSize * gridSize * gridSize)
    
    // Iterate over all the boundary cells in the grid. Eventually, we will
    // skip some internal cells to save time.
    for indexZ in 0..<gridSize {
      for indexY in 0..<gridSize {
        for indexX in 0..<gridSize {
          // Compute the center of the cell.
          let cellCenterX = (Float(indexX) + 0.5) * h
          let cellCenterY = (Float(indexY) + 0.5) * h
          let cellCenterZ = (Float(indexZ) + 0.5) * h
          let cellCenter = SIMD3<Float>(cellCenterX, cellCenterY, cellCenterZ)
          
          print()
          print(cellCenter)
          print("---------")
          
          // Compute the flux on each face.
          var flux: SIMD8<Float> = .zero
          for faceID in 0..<6 {
            let coordinateID = faceID / 2
            let signID = faceID % 2
            
            // Compute the center of the face.
            var faceCenter = cellCenter
            let coordinateDelta = (signID == 0) ? Float(-0.5) : 0.5
            faceCenter[coordinateID] += coordinateDelta * h
            print(faceCenter)
          }
        }
      }
    }
  }
  
  // Implementation of the algorithm from the INQ codebase, which chooses the
  // timestep based on the results of some integrals.
  func testSteepestDescent() throws {
    
  }
  
  // Implementation of weighted Jacobi, using a fixed timestep determined by
  // the grid spacing.
  func testWeightedJacobi() throws {
    
  }
  
  // Implementation of Gauss-Seidel, using a fixed timestep determined by the
  // grid spacing.
  //
  // This test does not cover the Gauss-Seidel red-black ordering scheme.
  // However, the results should reveal how one would go about coding GSRB.
  func testGaussSeidel() throws {
    
  }
  
  // Implementation of the algorithm from the INQ codebase, which chooses the
  // timestep based on the results of some integrals.
  func testConjugateGradient() throws {
    
  }
  
  // Multigrid solver. There's currently a big unknown regarding how the grid
  // should treat domain boundaries.
  func testMultigrid() throws {
    
  }
}
