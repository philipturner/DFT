import XCTest
import Mechanosynthesis
import Numerics

// A set of tests for solving the 3D potential generated by a nucleus.
//
// Use Neumann boundary conditions for these tests. Also, use the point
// charge model. This would be the multipole expansion of the charge
// distribution created by spreading the nucleus across 8 cells.
final class LinearSolverTests: XCTestCase {
  // First, check the solution from the direct matrix method. Make the domain
  // small enough that the direct method executes in ~1 ms. It may be too small
  // to observe a significant speedup from multigrid relaxations, but that is
  // okay. We only need code for a multigrid that works at all.
  func testDirectMatrixMethod() throws {
    // Set up the Neumann boundaries, normalize to obey Gauss's Law.
    let h: Float = 0.25
    let gridSize: Int = 8
    
    // Create an array that represents the boundary values in each cell.
    //
    // Elements of the flux data structure:
    // - [0] = lower X face
    // - [1] = upper X face
    // - [2] = lower Y face
    // - [3] = upper Y face
    // - [4] = lower Z face
    // - [5] = upper Z face
    var fluxGrid = [SIMD8<Float>](
      repeating: .zero, count: gridSize * gridSize * gridSize)
    
    // Iterate over all the boundary cells in the grid. Eventually, we will
    // skip some internal cells to save time.
    for indexZ in 0..<gridSize {
      for indexY in 0..<gridSize {
        for indexX in 0..<gridSize {
          // Compute the center of the cell.
          let cellCenterX = (Float(indexX) + 0.5) * h
          let cellCenterY = (Float(indexY) + 0.5) * h
          let cellCenterZ = (Float(indexZ) + 0.5) * h
          let cellCenter = SIMD3<Float>(cellCenterX, cellCenterY, cellCenterZ)
          
          print()
          print(cellCenter)
          print("---------")
          
          // Determine the flux on each face.
          var faceFluxes: SIMD8<Float> = .zero
          for faceID in 0..<6 {
            let coordinateID = faceID / 2
            let signID = faceID % 2
            
            // Compute the center of the face.
            var faceCenter = cellCenter
            let coordinateDelta = (signID == 0) ? Float(-0.5) : 0.5
            faceCenter[coordinateID] += coordinateDelta * h * 0
            
            // Place the nucleus at the midpoint of the 2D grid.
            let nucleusPosition = 0.5 * SIMD3(repeating: Float(gridSize) * h)
            
            // Find the distance and direction from the nucleus.
            let rDelta = faceCenter - nucleusPosition
            let distance = (rDelta * rDelta).sum().squareRoot()
            
            // The potential is always positive, while the gradient is always
            // negative.
            let gradient = -1 / (distance * distance)
            
            // Create the flux vector.
            let direction = rDelta / distance
            let flux = gradient * direction
            print(flux)
            
            // Select one scalar of the flux vector.
            var faceFlux = flux[coordinateID]
            faceFlux *= (signID == 0) ? -1 : 1
            faceFluxes[faceID] = distance // faceFlux
            
            // MARK: - Center
            
            // faceCenter
            // SIMD3<Float>(1.875, 1.875, 1.875)
            
            // rDelta
            // SIMD3<Float>(0.875, 0.875, 0.875)
            
            // distance
            // 1.5155444
            
            // gradient
            // -0.4353742
            
            // direction
            // SIMD3<Float>(0.57735026, 0.57735026, 0.57735026)
            
            // flux
            // SIMD3<Float>(-0.2513634, -0.2513634, -0.2513634)
            
            
            // MARK: - Faces
            
            // faceCenter
//            SIMD3<Float>(1.75, 1.875, 1.875)
//            SIMD3<Float>(2.0, 1.875, 1.875)
            
            // rDelta
//            SIMD3<Float>(0.75, 0.875, 0.875)
//            SIMD3<Float>(1.0, 0.875, 0.875)
            
            // distance
//            1.4469796
//            1.5909903
            
            // gradient
//            -0.47761193
//            -0.3950617
            
            // direction
//            SIMD3<Float>(0.51832104, 0.6047079, 0.6047079)
//            SIMD3<Float>(0.6285393, 0.54997194, 0.54997194)
            
            // flux
//            SIMD3<Float>(-0.24755631, -0.2888157, -0.2888157)
//            SIMD3<Float>(-0.24831182, -0.21727285, -0.21727285)
          }
          print(faceFluxes)
        }
      }
    }
  }
  
  // Implementation of the algorithm from the INQ codebase, which chooses the
  // timestep based on the results of some integrals.
  func testSteepestDescent() throws {
    
  }
  
  // Implementation of weighted Jacobi, using a fixed timestep determined by
  // the grid spacing.
  func testWeightedJacobi() throws {
    
  }
  
  // Implementation of Gauss-Seidel, using a fixed timestep determined by the
  // grid spacing.
  //
  // This test does not cover the Gauss-Seidel red-black ordering scheme.
  // However, the results should reveal how one would go about coding GSRB.
  func testGaussSeidel() throws {
    
  }
  
  // Implementation of the algorithm from the INQ codebase, which chooses the
  // timestep based on the results of some integrals.
  func testConjugateGradient() throws {
    
  }
  
  // Multigrid solver. There's currently a big unknown regarding how the grid
  // should treat domain boundaries.
  func testMultigrid() throws {
    
  }
}
