import XCTest
import Mechanosynthesis
import Numerics

// A set of tests for solving the 3D potential generated by a nucleus.
//
// Use Neumann boundary conditions for these tests. Also, use the point
// charge model. This would be the multipole expansion of the charge
// distribution created by spreading the nucleus across 8 cells.
final class LinearSolverTests: XCTestCase {
  static let h: Float = 0.25
  static let gridSize: Int = 8
  
  // Set up the Neumann boundaries, normalize to obey Gauss's Law.
  //
  // Returns an array of fluxes that must be present at the boundary.
  static func createBoundaryConditions() -> [SIMD8<Float>] {
    // Create an array that represents the boundary values in each cell.
    //
    // Elements of the flux data structure:
    // - [0] = lower X face
    // - [1] = upper X face
    // - [2] = lower Y face
    // - [3] = upper Y face
    // - [4] = lower Z face
    // - [5] = upper Z face
    var fluxGrid = [SIMD8<Float>](
      repeating: .zero, count: gridSize * gridSize * gridSize)
    
    // Iterate over all the boundary cells in the grid. Eventually, we will
    // skip some internal cells to save time.
    for indexZ in 0..<gridSize {
      for indexY in 0..<gridSize {
        // Skip some loop iterations to minimize execution time.
        var indicesX: [Int] = []
        if indexY == 0 || indexY == gridSize - 1 ||
            indexZ == 0 || indexZ == gridSize - 1 {
          for indexX in 0..<gridSize {
            indicesX.append(indexX)
          }
        } else {
          indicesX = [0, gridSize - 1]
        }
        
        for indexX in indicesX {
          // Compute the center of the cell.
          let cellCenterX = (Float(indexX) + 0.5) * h
          let cellCenterY = (Float(indexY) + 0.5) * h
          let cellCenterZ = (Float(indexZ) + 0.5) * h
          let cellCenter = SIMD3<Float>(cellCenterX, cellCenterY, cellCenterZ)
          
          // Determine the flux on each face.
          var faceFluxes: SIMD8<Float> = .zero
          for faceID in 0..<6 {
            let coordinateID = faceID / 2
            let signID = faceID % 2
            
            // Compute the center of the face.
            var faceCenter = cellCenter
            let coordinateDelta = (signID == 0) ? Float(-0.5) : 0.5
            faceCenter[coordinateID] += coordinateDelta * h
            
            // Place the nucleus at the midpoint of the 2D grid.
            let nucleusPosition = 0.5 * SIMD3(repeating: Float(gridSize) * h)
            
            // Find the distance and direction from the nucleus.
            let rDelta = faceCenter - nucleusPosition
            let distance = (rDelta * rDelta).sum().squareRoot()
            
            // The potential is always positive, while the gradient is always
            // negative.
            let gradient = -1 / (distance * distance)
            
            // Create the flux vector.
            let direction = rDelta / distance
            let flux = gradient * direction
            
            // Select one scalar of the flux vector.
            var faceFlux = flux[coordinateID]
            faceFlux *= (signID == 0) ? -1 : 1
            faceFluxes[faceID] = faceFlux
          }
          
          // Erase the fluxes on interior faces.
          let indices = SIMD3<Int>(indexX, indexY, indexZ)
          for coordinateID in 0..<3 {
            let index = indices[coordinateID]
            if index != 0 {
              faceFluxes[coordinateID * 2 + 0] = .zero
            }
            if index != gridSize - 1 {
              faceFluxes[coordinateID * 2 + 1] = .zero
            }
          }
          
          // Store the flux data structure to memory.
          var cellID = indexZ * (gridSize * gridSize)
          cellID += indexY * gridSize + indexX
          fluxGrid[cellID] = faceFluxes
        }
      }
    }
    
    // Correct to obey Gauss's Law.
    do {
      // Integrate the fluxes along the domain boundaries.
      var accumulator: Double = .zero
      for cellID in fluxGrid.indices {
        let faceFluxes = fluxGrid[cellID]
        let fluxTerm = faceFluxes.sum()
        let drTerm = h * h
        accumulator += Double(fluxTerm * drTerm)
      }
      let surfaceIntegral = Float(accumulator)
      
      // Rescale to reflect the charge enclosed.
      let chargeEnclosed: Float = 1
      let actual = surfaceIntegral
      let expected = -4 * Float.pi * chargeEnclosed
      let scaleFactor = expected / actual
      for cellID in fluxGrid.indices {
        var faceFluxes = fluxGrid[cellID]
        faceFluxes *= scaleFactor
        fluxGrid[cellID] = faceFluxes
      }
    }
    
    // Return the array of flux data structures.
    return fluxGrid
  }
  
  // First, check the solution from the direct matrix method. Make the domain
  // small enough that the direct method executes in ~1 ms. It may be too small
  // to observe a significant speedup from multigrid relaxations, but that is
  // okay. We only need code for a multigrid that works at all.
  func testDirectMatrixMethod() throws {
    
  }
  
  // Implementation of the algorithm from the INQ codebase, which chooses the
  // timestep based on the results of some integrals.
  func testSteepestDescent() throws {
    
  }
  
  // Implementation of weighted Jacobi, using a fixed timestep determined by
  // the grid spacing.
  func testWeightedJacobi() throws {
    
  }
  
  // Implementation of Gauss-Seidel, using a fixed timestep determined by the
  // grid spacing.
  //
  // This test does not cover the Gauss-Seidel red-black ordering scheme.
  // However, the results should reveal how one would go about coding GSRB.
  func testGaussSeidel() throws {
    
  }
  
  // Implementation of the algorithm from the INQ codebase, which chooses the
  // timestep based on the results of some integrals.
  func testConjugateGradient() throws {
    
  }
  
  // Multigrid solver. There's currently a big unknown regarding how the grid
  // should treat domain boundaries.
  func testMultigrid() throws {
    
  }
}
